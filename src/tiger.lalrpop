/// program ::=
/// exp
/// | decs
///
/// exp ::=
/// # Literals.
/// nil
/// | integer
/// | string
///
/// # Array and record creations.
/// | type-id [ exp ] of exp
/// | type-id {[ id = exp { , id = exp } ] }
///
/// # Object creation.
/// | new type-id
///
/// # Variables, field, elements of an array.
/// | lvalue
///
/// # Function call.
/// | id ( [ exp { , exp }] )
///
/// # Method call.
/// | lvalue . id ( [ exp { , exp }] )
///
/// # Operations.
/// | - exp
/// | exp op exp
/// | ( exps )
///
/// # Assignment.
/// | lvalue := exp
///
/// # Control structures.
/// | if exp then exp [else exp]
/// | while exp do exp
/// | for id := exp to exp do exp
/// | break
/// | let decs in exps end
///
/// lvalue ::= id
/// | lvalue . id
/// | lvalue [ exp ]
/// exps ::= [ exp { ; exp } ]
///
/// decs ::= { dec }
/// dec ::=
/// # Type declaration.
/// type id = ty
/// # Class definition (alternative form).
/// | class id [ extends type-id ] { classfields }
/// # Variable declaration.
/// | vardec
/// # Function declaration.
/// | function id ( tyfields ) [ : type-id ] = exp
/// # Primitive declaration.
/// | primitive id ( tyfields ) [ : type-id ]
/// # Importing a set of declarations.
/// | import string
///
/// vardec ::= var id [ : type-id ] := exp
///
/// classfields ::= { classfield }
/// # Class fields.
/// classfield ::=
/// # Attribute declaration.
/// vardec
/// # Method declaration.
/// | method id ( tyfields ) [ : type-id ] = exp
///
/// # Types.
/// ty ::=
/// # Type alias.
/// type-id
/// # Record type definition.
/// | { tyfields  }
/// # Array type definition.
/// | array of type-id
/// # Class definition (canonical form).
/// | class [ extends type-id ] { classfields }
/// tyfields ::= [ id : type-id { , id : type-id } ]
/// type-id ::= id
///
/// op ::= + | - | * | / | = | <> | > | < | >= | <= | & | |

use std::str::FromStr;
use ast::Exp::*;
use ast::Var::*;
use ast::Ty::*;
use ast::{Position, Symbol, Var, Exp, FunDecl, TypeDecl, Dec, Field, Ty, Oper};
use lexer::Token;

grammar;

extern {
    type Location = usize;
    enum Token {

"(" => Token::LParen,
")" => Token::RParen,
"[" => Token::LBracket,
"]" => Token::RBracket,
"{" => Token::LBrace,
"}" => Token::RBrace,

"," => Token::Comma,
";" => Token::SemiColon,
":" => Token::Colon,

"." => Token::Dot,
"+" => Token::Plus,
"-" => Token::Minus,
"*" => Token::Star,
"/" => Token::Slash,
"=" => Token::Equal,
"<>" => Token::NotEqual,
"<" => Token::Lower,
"<=" => Token::LowerEqual,
">" => Token::Greater,
">=" => Token::GreaterEqual,
"&" => Token::Ampersand,
"|" => Token::Pipe,
":=" => Token::Assign,

"nil" => Token::Nil,
"of" => Token::Of,
"while" => Token::While,
"for" => Token::For,
"to" => Token::To,
"break" => Token::Break,
"let" => Token::Let,
"in" => Token::In,
"end" => Token::End,
"function" => Token::Function,
"var" => Token::Var,
"type" => Token::Type,
"array" => Token::Array,
"if" => Token::If,
"then" => Token::Then,
"else" => Token::Else,
"new" => Token::New,
"do" => Token::Do,

Integer => Token::Integer(<i32>),
Ident => Token::Ident(<String>),
String => Token::String(<String>),

    }
}

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


pub Program: Box<Exp> = {
   Exp,
};

Exp: Box<Exp> = {
   "nil" => Box::new(NilExp),
   Integer => Box::new(IntExp(<>)),
   <l:@L> <s:String> => Box::new(StringExp(s, l)),

   <pos:@L> <is:IdentSubscript> "of" <init:Exp> =>
      Box::new(ArrayExp { typ: is.0, size: is.1, init: init, pos: pos } ),

   <pos:@L> <typ:Ident> "{" <fields:Fields> "}" =>
      Box::new(RecordExp { typ: typ, fields: fields, pos: pos}),

   <pos:@L> "new" <typ:Ident> => Box::new(NewExp(typ, pos)),

   Var => Box::new(VarExp(<>)),
};

IdentSubscript: (Symbol, Box<Exp>) = {
   <typ:Ident> "[" <size:Exp> "]" => (typ, size),
};

Var: Box<Var> = {
   <pos:@L> <id:Ident> => Box::new(SimpleVar(id, pos)),
   ComplexVar,
};

ComplexVar: Box<var> = {
   <pos:@L> <v:Var> "." <fid:Ident> => Box::new(FieldVar(v, fid, pos)),
   <pos:@L> <is:IdentSubscript> => Box::new(SubscriptVar(Box::new(SimpleVar(is.0, pos)), e, pos)),
   <pos:@L> <v:Var> "[" <e:Exp> "]" => Box::new(SubscriptVar(v, e, pos)),
};

Fields = Comma<Field>;
Field: (Symbol, Box<Exp>, Position) = {
   <pos:@L> <id:Ident> "=" <e:Exp> => (id, e, pos),
};

